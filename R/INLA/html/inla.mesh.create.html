<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Low level function for high-quality triangulations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for inla.mesh.create {INLA}"><tr><td>inla.mesh.create {INLA}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Low level function for high-quality triangulations</h2>

<h3>Description</h3>

<p>Create a constrained refined Delaunay triangulation (CRDT) for a set of
spatial locations.
</p>


<h3>Usage</h3>

<pre>
inla.mesh.create(
  loc = NULL,
  tv = NULL,
  boundary = NULL,
  interior = NULL,
  extend = (missing(tv) || is.null(tv)),
  refine = FALSE,
  lattice = NULL,
  globe = NULL,
  cutoff = 1e-12,
  plot.delay = NULL,
  data.dir,
  keep = (!missing(data.dir) &amp;&amp; !is.null(data.dir)),
  timings = FALSE,
  quality.spec = NULL,
  crs = NULL
)

inla.delaunay(loc, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>loc</code></td>
<td>
<p>Matrix of point locations.  Can alternatively be a
<code>SpatialPoints</code> or <code>SpatialPointsDataFrame</code> object.</p>
</td></tr>
<tr valign="top"><td><code>tv</code></td>
<td>
<p>A triangle-vertex index matrix, specifying an existing
triangulation.</p>
</td></tr>
<tr valign="top"><td><code>boundary</code></td>
<td>
<p>A list of <code>inla.mesh.segment</code> objects, generated by
<code><a href="../../INLA/help/inla.mesh.segment.html">inla.mesh.segment()</a></code>, specifying boundary constraint segments.</p>
</td></tr>
<tr valign="top"><td><code>interior</code></td>
<td>
<p>A list of <code>inla.mesh.segment</code> objects, generated by
<code><a href="../../INLA/help/inla.mesh.segment.html">inla.mesh.segment()</a></code>, specifying interior constraint segments.</p>
</td></tr>
<tr valign="top"><td><code>extend</code></td>
<td>
<p><code>logical</code> or <code>list</code> specifying whether to extend the
data region, with parameters </p>
 <dl>
<dt>list(&quot;n&quot;)</dt><dd><p>the number of edges
in the extended boundary (default=8)</p>
</dd> <dt>list(&quot;offset&quot;)</dt><dd><p>the extension
distance.  If negative, interpreted as a factor relative to the approximate
data diameter (default=-0.10)</p>
</dd> </dl>
<p> Setting to <code>FALSE</code> is only useful in
combination <code>lattice</code> or <code>boundary</code>.</p>
</td></tr>
<tr valign="top"><td><code>refine</code></td>
<td>
<p><code>logical</code> or <code>list</code> specifying whether to refine the
triangulation, with parameters </p>
 <dl>
<dt>list(&quot;min.angle&quot;)</dt><dd><p>the
minimum allowed interior angle in any triangle.  The algorithm is guaranteed
to converge for <code>min.angle</code> at most 21 (default=<code>21</code>)</p>
</dd>
<dt>list(&quot;max.edge&quot;)</dt><dd><p>the maximum allowed edge length in any triangle.  If
negative, interpreted as a relative factor in an ad hoc formula depending on
the data density (default=<code>Inf</code>)</p>
</dd> <dt>list(&quot;max.n.strict&quot;)</dt><dd><p>the
maximum number of vertices allowed, overriding <code>min.angle</code> and
<code>max.edge</code> (default=-1, meaning no limit)</p>
</dd> <dt>list(&quot;max.n&quot;)</dt><dd><p>the
maximum number of vertices allowed, overriding <code>max.edge</code> only
(default=-1, meaning no limit)</p>
</dd> </dl>
</td></tr>
<tr valign="top"><td><code>lattice</code></td>
<td>
<p>An <code>inla.mesh.lattice</code> object, generated by
<code><a href="../../INLA/help/inla.mesh.lattice.html">inla.mesh.lattice()</a></code>, specifying points on a regular lattice.</p>
</td></tr>
<tr valign="top"><td><code>globe</code></td>
<td>
<p>Subdivision resolution for a semi-regular spherical
triangulation with equidistant points along equidistant latitude bands.</p>
</td></tr>
<tr valign="top"><td><code>cutoff</code></td>
<td>
<p>The minimum allowed distance between points.  Point at most as
far apart as this are replaced by a single vertex prior to the mesh
refinement step.</p>
</td></tr>
<tr valign="top"><td><code>plot.delay</code></td>
<td>
<p>On Linux (and Mac if appropriate X11 libraries are
installed), specifying a numeric value activates a rudimentary plotting
system in the underlying <code>fmesher</code> program, showing the triangulation
algorithm at work.</p>
</td></tr>
<tr valign="top"><td><code>data.dir</code></td>
<td>
<p>Where to store the <code>fmesher</code> data files.  Defaults to
<code>tempdir()</code> if <code>keep</code> is <code>FALSE</code>, otherwise
<code>"inla.mesh.data"</code>.</p>
</td></tr>
<tr valign="top"><td><code>keep</code></td>
<td>
<p><code>TRUE</code> if the data files should be kept in <code>data.dir</code>
or deleted afterwards.  Defaults to true if <code>data.dir</code> is specified,
otherwise false.  Warning: If <code>keep</code> is false, <code>data.dir</code> and its
contents will be deleted (unless set to <code>tempdir()</code>).</p>
</td></tr>
<tr valign="top"><td><code>timings</code></td>
<td>
<p>If <code>TRUE</code>, obtain timings for the mesh construction.</p>
</td></tr>
<tr valign="top"><td><code>quality.spec</code></td>
<td>
<p>List of vectors of per vertex <code>max.edge</code> target
specification for each location in <code>loc</code>, <code>boundary/interior</code>
(<code>segm</code>), and <code>lattice</code>.  Only used if refining the mesh.</p>
</td></tr>
<tr valign="top"><td><code>crs</code></td>
<td>
<p>An optional <code>CRS</code> or <code>inla.CRS</code> object</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Optional parameters passed on to <code>inla.mesh.create</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>inla.mesh.create</code> generates triangular meshes on subsets of
<i>R^2</i> and <i>S^2</i>.  Use the higher level wrapper function
<code><a href="../../INLA/help/inla.mesh.2d.html">inla.mesh.2d()</a></code> for greater control over mesh resolution and
coarser domain extensions.
</p>
<p><code>inla.delaunay</code> is a wrapper function for obtaining the convex hull of
a point set and calling <code>inla.mesh.create</code> to generate the classical
Delaunay tringulation.
</p>


<h3>Value</h3>

<p>An <code>inla.mesh</code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="../../INLA/help/inla.mesh.2d.html">inla.mesh.2d()</a></code>, <code><a href="../../INLA/help/inla.mesh.1d.html">inla.mesh.1d()</a></code>,
<code><a href="../../INLA/help/inla.mesh.segment.html">inla.mesh.segment()</a></code>, <code><a href="../../INLA/help/inla.mesh.lattice.html">inla.mesh.lattice()</a></code>,
<code><a href="../../INLA/help/inla.mesh.query.html">inla.mesh.query()</a></code>
</p>


<h3>Examples</h3>

<pre>

loc &lt;- matrix(runif(10 * 2), 10, 2)

mesh &lt;- inla.delaunay(loc)
plot(mesh)

mesh &lt;- inla.mesh.create(loc,
    interior = inla.mesh.segment(idx = 1:2),
    extend = TRUE,
    refine = list(max.edge = 0.1)
)
plot(mesh)

loc2 &lt;- matrix(c(0, 1, 1, 0, 0, 0, 1, 1), 4, 2)
mesh2 &lt;- inla.mesh.create(
    loc = loc,
    boundary = inla.mesh.segment(loc2),
    interior = inla.mesh.segment(idx = 1:2),
    quality.spec = list(segm = 0.2, loc = 0.05),
    refine = list(min.angle = 26)
)
plot(mesh2)
</pre>

<hr /><div style="text-align: center;">[Package <em>INLA</em> version 22.02.16-2 <a href="00Index.html">Index</a>]</div>
</div></body></html>
