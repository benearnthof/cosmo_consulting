<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Matern SPDE model object for INLA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for inla.spde2.matern {INLA}"><tr><td>inla.spde2.matern {INLA}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Matern SPDE model object for INLA</h2>

<h3>Description</h3>

<p>Create an <code>inla.spde2</code> model object for a Matern model. Use
<code>inla.spde2.pcmatern</code> instead for a PC prior for the parameters.
</p>


<h3>Usage</h3>

<pre>
inla.spde2.matern(
  mesh,
  alpha = 2,
  param = NULL,
  constr = FALSE,
  extraconstr.int = NULL,
  extraconstr = NULL,
  fractional.method = c("parsimonious", "null"),
  B.tau = matrix(c(0, 1, 0), 1, 3),
  B.kappa = matrix(c(0, 0, 1), 1, 3),
  prior.variance.nominal = 1,
  prior.range.nominal = NULL,
  prior.tau = NULL,
  prior.kappa = NULL,
  theta.prior.mean = NULL,
  theta.prior.prec = 0.1,
  n.iid.group = 1,
  ...
)

inla.spde2.theta2phi0(spde, theta)

inla.spde2.theta2phi1(spde, theta)

inla.spde2.theta2phi2(spde, theta)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>mesh</code></td>
<td>
<p>The mesh to build the model on, as an <code><a href="../../INLA/help/inla.mesh.html">inla.mesh()</a></code> or
<code><a href="../../INLA/help/inla.mesh.1d.html">inla.mesh.1d()</a></code> object.</p>
</td></tr>
<tr valign="top"><td><code>alpha</code></td>
<td>
<p>Fractional operator order, <i>0&lt;&alpha;&le;q 2</i> supported.
(<i>&nu;=&alpha;-d/2</i>)</p>
</td></tr>
<tr valign="top"><td><code>param</code></td>
<td>
<p>Parameter, e.g. generated by <code>param2.matern.orig</code></p>
</td></tr>
<tr valign="top"><td><code>constr</code></td>
<td>
<p>If <code>TRUE</code>, apply an integrate-to-zero constraint.
Default <code>FALSE</code>.</p>
</td></tr>
<tr valign="top"><td><code>extraconstr.int</code></td>
<td>
<p>Field integral constraints.</p>
</td></tr>
<tr valign="top"><td><code>extraconstr</code></td>
<td>
<p>Direct linear combination constraints on the basis
weights.</p>
</td></tr>
<tr valign="top"><td><code>fractional.method</code></td>
<td>
<p>Specifies the approximation method to use for
fractional (non-integer) <code>alpha</code> values. <code>'parsimonious'</code> gives an
overall approximate minimal covariance error, <code>'null'</code> uses
approximates low-order properties.</p>
</td></tr>
<tr valign="top"><td><code>B.tau</code></td>
<td>
<p>Matrix with specification of log-linear model for <i>&tau;</i>.</p>
</td></tr>
<tr valign="top"><td><code>B.kappa</code></td>
<td>
<p>Matrix with specification of log-linear model for
<i>&kappa;</i>.</p>
</td></tr>
<tr valign="top"><td><code>prior.variance.nominal</code></td>
<td>
<p>Nominal prior mean for the field variance</p>
</td></tr>
<tr valign="top"><td><code>prior.range.nominal</code></td>
<td>
<p>Nominal prior mean for the spatial range</p>
</td></tr>
<tr valign="top"><td><code>prior.tau</code></td>
<td>
<p>Prior mean for tau (overrides
<code>prior.variance.nominal</code>)</p>
</td></tr>
<tr valign="top"><td><code>prior.kappa</code></td>
<td>
<p>Prior mean for kappa (overrides
<code>prior.range.nominal</code>)</p>
</td></tr>
<tr valign="top"><td><code>theta.prior.mean</code></td>
<td>
<p>(overrides <code style="white-space: pre;">prior.*</code>)</p>
</td></tr>
<tr valign="top"><td><code>theta.prior.prec</code></td>
<td>
<p>Scalar, vector or matrix, specifying the joint prior
precision for <i>theta</i>.</p>
</td></tr>
<tr valign="top"><td><code>n.iid.group</code></td>
<td>
<p>If greater than 1, build an explicitly iid replicated
model, to support constraints applied to the combined replicates, for
example in a time-replicated spatial model. Constraints can either be
specified for a single mesh, in which case it's applied to the average of
the replicates (<code>ncol(A)</code> should be <code>mesh$n</code> for 2D meshes,
<code>mesh$m</code> for 1D), or as general constraints on the collection of
replicates (<code>ncol(A)</code> should be <code>mesh$n * n.iid.group</code> for 2D
meshes, <code>mesh$m * n.iid.group</code> for 1D).</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Additional parameters for special uses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method constructs a Matern SPDE model, with spatial scale parameter
<i>&kappa;(u)</i> and variance rescaling parameter <i>&tau;(u)</i>.
</p>
<p style="text-align: center;"><i>(kappa^2(u)-Delta)^(alpha/2)
(tau(u) x(u)) = W(u)</i></p>
<p style="text-align: center;"><i>(kappa^2(u)-Delta)^(alpha/2) (tau(u)
x(u)) = W(u)</i></p>

<p>Stationary models are supported for <i>0 &lt; &alpha; &le;q 2</i>, with spectral
approximation methods used for non-integer <i>&alpha;</i>, with approximation
method determined by <code>fractional.method</code>.
</p>
<p>Non-stationary models are supported for <i>&alpha;=2</i> only, with </p>

<ul>
<li> <p><i>log tau(u)
= B.tau_0(u) + sum_{k=1}^p B.tau_k(u) theta_k</i><i>log tau(u) =
B.tau_0(u) + sum_{k=1}^p B.tau_k(u) theta_k</i>
</p>
</li>
<li> <p><i>log kappa(u) = B.kappa_0(u) + sum_{k=1}^p B.kappa_k(u) theta_k</i><i>log kappa(u) = B.kappa_0(u) + sum_{k=1}^p B.kappa_k(u) theta_k</i>
</p>
</li></ul>

<p>The same parameterisation is used in the stationary cases, but with
<i>B^&tau;_0</i>, <i>B^&tau;_k</i>, <i>B^&kappa;_0</i>, and <i>B^&tau;_k</i>
constant across <i>u</i>.
</p>
<p>Integration and other general linear constraints are supported via the
<code>constr</code>, <code>extraconstr.int</code>, and <code>extraconstr</code> parameters,
which also interact with <code>n.iid.group</code>.
</p>


<h3>Value</h3>

<p>An <code>inla.spde2</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>inla.spde2.theta2phi0</code>: Convert from theta vector to phi0 values in
the internal spde2 model representation
</p>
</li>
<li> <p><code>inla.spde2.theta2phi1</code>: Convert from theta vector to phi1 values in
the internal spde2 model representation
</p>
</li>
<li> <p><code>inla.spde2.theta2phi2</code>: Convert from theta vector to phi2 values in
the internal spde2 model representation
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="../../INLA/help/inla.mesh.2d.html">inla.mesh.2d()</a></code>, <code><a href="../../INLA/help/inla.mesh.create.html">inla.mesh.create()</a></code>,
<code><a href="../../INLA/help/inla.mesh.1d.html">inla.mesh.1d()</a></code>, <code><a href="../../INLA/help/inla.mesh.basis.html">inla.mesh.basis()</a></code>,
<code><a href="../../INLA/help/inla.spde2.pcmatern.html">inla.spde2.pcmatern()</a></code>, <code><a href="../../INLA/help/inla.spde2.generic.html">inla.spde2.generic()</a></code>
</p>


<h3>Examples</h3>

<pre>

n = 100
field.fcn = function(loc) (10*cos(2*pi*2*(loc[,1]+loc[,2])))
loc = matrix(runif(n*2),n,2)
## One field, 2 observations per location
idx.y = rep(1:n,2)
y = field.fcn(loc[idx.y,]) + rnorm(length(idx.y))

mesh = inla.mesh.create(loc, refine=list(max.edge=0.05))
spde = inla.spde2.matern(mesh)
data = list(y=y, field=mesh$idx$loc[idx.y])
formula = y ~ -1 + f(field, model=spde)
result = inla(formula, data=data, family="normal")

## Plot the mesh structure:
plot(mesh)

if (require(rgl)) {
  col.pal = colorRampPalette(c("blue","cyan","green","yellow","red"))
  ## Plot the posterior mean:
  plot(mesh, rgl=TRUE,
       result$summary.random$field[,"mean"],
       color.palette = col.pal)
  ## Plot residual field:
  plot(mesh, rgl=TRUE,
       result$summary.random$field[,"mean"]-field.fcn(mesh$loc),
       color.palette = col.pal)
}

result.field = inla.spde.result(result, "field", spde)
plot(result.field$marginals.range.nominal[[1]])

</pre>

<hr /><div style="text-align: center;">[Package <em>INLA</em> version 22.02.16-2 <a href="00Index.html">Index</a>]</div>
</div></body></html>
