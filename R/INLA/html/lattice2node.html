<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Functions to define mapping between a lattice and nodes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for lattice2node {INLA}"><tr><td>lattice2node {INLA}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Functions to define mapping between a lattice and nodes</h2>

<h3>Description</h3>

<p>These functions define mapping in between two-dimensional
indices on a lattice and the one-dimensional node representation used
in <code>inla</code>.
</p>
<p>The mapping from node to lattice follows the default <code>R</code>
behaviour (which is column based storage), and <code>as.vector(A)</code> and
<code>matrix(a, nrow, ncol)</code> can be used instead of
<code>inla.matrix2vector</code> and <code>inla.vector2matrix</code>.
</p>


<h3>Usage</h3>

<pre>
inla.lattice2node.mapping(nrow, ncol)
inla.node2lattice.mapping(nrow, ncol)
inla.lattice2node(irow, icol, nrow, ncol)
inla.node2lattice(node, nrow, ncol)
inla.matrix2vector(a.matrix)
inla.vector2matrix(a.vector, nrow, ncol)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>nrow</code></td>
<td>
<p>Number of rows in the lattice.</p>
</td></tr>
<tr valign="top"><td><code>ncol</code></td>
<td>
<p>Number of columns in the lattice.</p>
</td></tr>
<tr valign="top"><td><code>irow</code></td>
<td>
<p>Lattice row index, between <code>1</code> and <code>nrow</code></p>
</td></tr>
<tr valign="top"><td><code>icol</code></td>
<td>
<p>Lattice column index, between <code>1</code> and <code>ncol</code></p>
</td></tr>
<tr valign="top"><td><code>node</code></td>
<td>
<p>The node index, between <code>1</code> and <code>ncol*nrow</code></p>
</td></tr>
<tr valign="top"><td><code>a.matrix</code></td>
<td>
<p>is a matrix to be mapped to a vector using internal
representation defined by <code>inla.lattice2node</code></p>
</td></tr>
<tr valign="top"><td><code>a.vector</code></td>
<td>
<p>is a vector to be mapped into a matrix using the
internal representation defined by <code>inla.node2lattice</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>inla.lattice2node.mapping</code> returns the hole mapping as a
matrix, and <code>inla.node2lattice.mapping</code> returns the hole mapping
as <code>list(irow=..., icol=...)</code>. <code>inla.lattice2node</code> and
<code>inla.node2lattice</code> provide the mapping for a given set of
lattice indices and nodes. <code>inla.matrix2vector</code> provide the
mapped vector from a matrix, and <code>inla.vector2matrix</code> provide the
inverse mapped matrix from vector.</p>


<h3>Author(s)</h3>

<p>Havard Rue <a href="mailto:hrue@r-inla.org">hrue@r-inla.org</a></p>


<h3>See Also</h3>

<p><a href="../../INLA/help/inla.html">inla</a></p>


<h3>Examples</h3>

<pre>
## write out the mapping using the two alternatives
nrow = 2
ncol = 3
mapping = inla.lattice2node.mapping(nrow,ncol)

for (i in 1:nrow){
    for(j in 1:ncol){
        print(paste("Alt.1: lattice index [", i,",", j,"] corresponds",
                    "to node [", mapping[i,j],"]", sep=""))
    }
}

for (i in 1:nrow){
    for(j in 1:ncol){
        print(paste("Alt.2: lattice index [", i,",", j,"] corresponds to node [",
                    inla.lattice2node(i,j,nrow,ncol), "]", sep=""))
    }
}

inv.mapping = inla.node2lattice.mapping(nrow,ncol)
for(node in 1:(nrow*ncol))
   print(paste("Alt.1: node [", node, "] corresponds to lattice index [",
               inv.mapping$irow[node], ",",
               inv.mapping$icol[node],"]", sep=""))

for(node in 1:(nrow*ncol))
   print(paste("Alt.2: node [", node, "] corresponds to lattice index [",
               inla.node2lattice(node,nrow,ncol)$irow[1], ",",
               inla.node2lattice(node,nrow,ncol)$icol[1],"]", sep=""))

## apply the mapping from matrix to vector and back
n = nrow*ncol
z = matrix(1:n,nrow,ncol)
z.vector = inla.matrix2vector(z)  # as.vector(z) could also be used
print(mapping)
print(z)
print(z.vector)

## the vector2matrix is the inverse, and should give us the z-matrix
## back. matrix(z.vector, nrow, ncol) could also be used here.
z.matrix = inla.vector2matrix(z.vector, nrow, ncol)
print(z.matrix)
</pre>

<hr /><div style="text-align: center;">[Package <em>INLA</em> version 22.02.16-2 <a href="00Index.html">Index</a>]</div>
</div></body></html>
