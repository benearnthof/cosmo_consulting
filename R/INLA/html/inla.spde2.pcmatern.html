<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Matern SPDE model object with PC prior for INLA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for inla.spde2.pcmatern {INLA}"><tr><td>inla.spde2.pcmatern {INLA}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Matern SPDE model object with PC prior for INLA</h2>

<h3>Description</h3>

<p>Create an <code>inla.spde2</code> model object for a Matern model, using a PC
prior for the parameters.
</p>


<h3>Usage</h3>

<pre>
inla.spde2.pcmatern(
  mesh,
  alpha = 2,
  param = NULL,
  constr = FALSE,
  extraconstr.int = NULL,
  extraconstr = NULL,
  fractional.method = c("parsimonious", "null"),
  n.iid.group = 1,
  prior.range = NULL,
  prior.sigma = NULL
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>mesh</code></td>
<td>
<p>The mesh to build the model on, as an <code><a href="../../INLA/help/inla.mesh.html">inla.mesh()</a></code> or
<code><a href="../../INLA/help/inla.mesh.1d.html">inla.mesh.1d()</a></code> object.</p>
</td></tr>
<tr valign="top"><td><code>alpha</code></td>
<td>
<p>Fractional operator order, <i>0 &lt; alpha &lt;= 2</i>
supported, for <i>&nu;=&alpha;-d/2&gt;0</i>.</p>
</td></tr>
<tr valign="top"><td><code>param</code></td>
<td>
<p>Further model parameters. Not currently used.</p>
</td></tr>
<tr valign="top"><td><code>constr</code></td>
<td>
<p>If <code>TRUE</code>, apply an integrate-to-zero constraint.
Default <code>FALSE</code>.</p>
</td></tr>
<tr valign="top"><td><code>extraconstr.int</code></td>
<td>
<p>Field integral constraints.</p>
</td></tr>
<tr valign="top"><td><code>extraconstr</code></td>
<td>
<p>Direct linear combination constraints on the basis
weights.</p>
</td></tr>
<tr valign="top"><td><code>fractional.method</code></td>
<td>
<p>Specifies the approximation method to use for
fractional (non-integer) <code>alpha</code> values. <code>'parsimonious'</code> gives an
overall approximate minimal covariance error, <code>'null'</code> uses
approximates low-order properties.</p>
</td></tr>
<tr valign="top"><td><code>n.iid.group</code></td>
<td>
<p>If greater than 1, build an explicitly iid replicated
model, to support constraints applied to the combined replicates, for
example in a time-replicated spatial model. Constraints can either be
specified for a single mesh, in which case it's applied to the average of
the replicates (<code>ncol(A)</code> should be <code>mesh$n</code> for 2D meshes,
<code>mesh$m</code> for 1D), or as general constraints on the collection of
replicates (<code>ncol(A)</code> should be <code>mesh$n * n.iid.group</code> for 2D
meshes, <code>mesh$m * n.iid.group</code> for 1D).</p>
</td></tr>
<tr valign="top"><td><code>prior.range</code></td>
<td>
<p>A length 2 vector, with <code style="white-space: pre;">(range0,Prange)</code> specifying
that <i>P(&rho; &lt; &rho;_0)=p_&rho;</i>, where <i>&rho;</i> is the spatial range of
the random field. If <code>Prange</code> is <code>NA</code>, then <code>range0</code> is used
as a fixed range value.</p>
</td></tr>
<tr valign="top"><td><code>prior.sigma</code></td>
<td>
<p>A length 2 vector, with <code style="white-space: pre;">(sigma0,Psigma)</code> specifying
that <i>P(&sigma; &gt; &sigma;_0)=p_&sigma;</i>, where <i>&sigma;</i> is the marginal
standard deviation of the field.  If <code>Psigma</code> is <code>NA</code>, then
<code>sigma0</code> is used as a fixed range value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method constructs a Matern SPDE model, with spatial range <i>&rho;</i>
and standard deviation parameter <i>&sigma;</i>.  In the parameterisation
</p>
<p style="text-align: center;"><i>(kappa^2-Delta)^(alpha/2) (tau
x(u)) = W(u)</i></p>
<p style="text-align: center;"><i>(kappa^2-Delta)^(alpha/2) (tau x(u)) = W(u)</i></p>

<p>the spatial scale parameter <i>&kappa;=&radic;{8&nu;}/&rho;</i>, where
<i>&nu;=&alpha;-d/2</i>, and <i>&tau;</i> is proportional to <i>1/&sigma;</i>.
</p>
<p>Stationary models are supported for <i>0 &lt; alpha &lt;= 2</i>,
with spectral approximation methods used for non-integer <i>&alpha;</i>, with
approximation method determined by <code>fractional.method</code>.
</p>
<p>Integration and other general linear constraints are supported via the
<code>constr</code>, <code>extraconstr.int</code>, and <code>extraconstr</code> parameters,
which also interact with <code>n.iid.group</code>.
</p>
<p>The joint PC prior density for the spatial range, <i>&rho;</i>, and the
marginal standard deviation, <i>&sigma;</i>, and is </p>
<p style="text-align: center;"><i>p(rho, sigma) =
(d R)/2 rho^(-1-d/2) exp(-R rho^(-d/2)) S exp(-S sigma) </i></p>
<p style="text-align: center;"><i>p(rho, sigma) = (d R)/2 rho^(-1-d/2) exp(-R rho^(-d/2)) S exp(-S
sigma) </i></p>
<p style="text-align: center;"><i>p(rho, sigma) = (d R)/2 rho^(-1-d/2) exp(-R rho^(-d/2)) S
exp(-S sigma) </i></p>
<p style="text-align: center;"><i>p(rho,
sigma) = (d R)/2 rho^(-1-d/2) exp(-R rho^(-d/2)) S exp(-S sigma) </i></p>
<p> where
<i>R</i> and <i>S</i> are hyperparameters that
must be determined by the analyst. The practical approach for this in INLA
is to require the user to indirectly specify these hyperparameters through
</p>
<p style="text-align: center;"><i>P(&rho; &lt; &rho;_0) = p_&rho;</i></p>
<p> and </p>
<p style="text-align: center;"><i>P(&sigma; &gt; &sigma;_0) = p_&sigma;</i></p>

<p>where the user specifies the lower tail quantile and probability for the
range (<i>&rho;_0</i> and <i>p_&rho;</i>) and the upper tail quantile and
probability for the standard deviation (<i>&sigma;_0</i> and
<i>&alpha;_&sigma;</i>).
</p>
<p>This allows the user to control the priors of the parameters by supplying
knowledge of the scale of the problem. What is a reasonable upper magnitude
for the spatial effect and what is a reasonable lower scale at which the
spatial effect can operate? The shape of the prior was derived through a
construction that shrinks the spatial effect towards a base model of no
spatial effect in the sense of distance measured by Kullback-Leibler
divergence.
</p>
<p>The prior is constructed in two steps, under the idea that having a spatial
field is an extension of not having a spatial field. First, a spatially
constant random effect (<i>&rho; = &infin;</i>) with finite variance is more
complex than not having a random effect (<i>&sigma; = 0</i>). Second, a
spatial field with spatial variation (<i>&rho; &lt; &infin;</i>) is more complex
than the random effect with no spatial variation. Each of these extensions
are shrunk towards the simpler model and, as a result, we shrink the spatial
field towards the base model of no spatial variation and zero variance
(<i>&rho; = &infin;</i> and <i>&sigma; = 0</i>).
</p>
<p>The details behind the construction of the prior is presented in Fuglstad,
et al. (2016) and is based on the PC prior framework (Simpson, et al.,
2015).
</p>


<h3>Value</h3>

<p>An <code>inla.spde2</code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>References</h3>

<p>Fuglstad, G.-A., Simpson, D., Lindgren, F., and Rue, H. (2016)
Constructing Priors that Penalize the Complexity of Gaussian Random Fields.
arXiv:1503.00256
</p>
<p>Simpson, D., Rue, H., Martins, T., Riebler, A., and SÃ¸rbye, S. (2015)
Penalising model component complexity: A principled, practical approach to
constructing priors. arXiv:1403.4630
</p>


<h3>See Also</h3>

<p><code><a href="../../INLA/help/inla.mesh.2d.html">inla.mesh.2d()</a></code>, <code><a href="../../INLA/help/inla.mesh.create.html">inla.mesh.create()</a></code>,
<code><a href="../../INLA/help/inla.mesh.1d.html">inla.mesh.1d()</a></code>, <code><a href="../../INLA/help/inla.mesh.basis.html">inla.mesh.basis()</a></code>,
<code><a href="../../INLA/help/inla.spde2.matern.html">inla.spde2.matern()</a></code>, <code><a href="../../INLA/help/inla.spde2.generic.html">inla.spde2.generic()</a></code>
</p>


<h3>Examples</h3>

<pre>

## Spatial interpolation
  n = 100
  field.fcn = function(loc) (10*cos(2*pi*2*(loc[,1]+loc[,2])))
  loc = matrix(runif(n*2),n,2)
  ## One field, 2 observations per location
  idx.y = rep(1:n,2)
  y = field.fcn(loc[idx.y,]) + rnorm(length(idx.y))

  mesh = inla.mesh.2d(loc, max.edge=0.05, cutoff=0.01)
  spde = inla.spde2.pcmatern(mesh,
           prior.range=c(0.01,0.1), prior.sigma=c(100,0.1))
  data = list(y=y, field=mesh$idx$loc[idx.y])
  formula = y ~ -1 + f(field, model=spde)
  result = inla(formula, data=data, family="normal")

  ## Plot the mesh structure:
  plot(mesh)
  
  if (require(rgl)) {
    col.pal = colorRampPalette(c("blue","cyan","green","yellow","red"))
    ## Plot the posterior mean:
    plot(mesh, rgl=TRUE,
         result$summary.random$field[,"mean"],
         color.palette = col.pal)
    ## Plot residual field:
    plot(mesh, rgl=TRUE,
         result$summary.random$field[,"mean"]-field.fcn(mesh$loc),
         color.palette = col.pal)
  }
  

  result.field = inla.spde.result(result, "field", spde)
  par(mfrow=c(2,1))
  plot(result.field$marginals.range.nominal[[1]],
       type="l", main="Posterior density for range")
  plot(inla.tmarginal(sqrt, result.field$marginals.variance.nominal[[1]]),
       type="l", main="Posterior density for std.dev.")
  par(mfrow=c(1,1))

## Spatial model
  set.seed(1234234)
  
  ## Generate spatial locations
  nObs = 200
  loc = matrix(runif(nObs*2), nrow = nObs, ncol = 2)

  ## Generate observation of spatial field
  nu = 1.0
  rhoT = 0.2
  kappaT = sqrt(8*nu)/rhoT
  sigT = 1.0
  Sig = sigT^2*inla.matern.cov(nu = nu,
                               kappa = kappaT,
                               x = as.matrix(dist(loc)),
                               d = 2,
                               corr = TRUE)
  L = t(chol(Sig))
  u = L %*% rnorm(nObs)

  ## Construct observation with nugget
  sigN = 0.1
  y = u + sigN*rnorm(nObs)

  ## Create the mesh and spde object
  mesh = inla.mesh.2d(loc,
                      max.edge = 0.05,
                      cutoff = 0.01)
  spde = inla.spde2.pcmatern(mesh,
                             prior.range = c(0.01, 0.05),
                             prior.sigma = c(10, 0.05))

  ## Create projection matrix for observations
  A = inla.spde.make.A(mesh = mesh,
                       loc = loc)

  ## Run model without any covariates
  idx = 1:spde$n.spde
  res = inla(y ~ f(idx, model = spde) - 1,
             data = list(y = y, idx = idx, spde = spde),
             control.predictor = list(A = A))

## Re-run model with fixed range
  spde.fixed = inla.spde2.pcmatern(mesh,
                                   prior.range = c(0.2, NA),
                                   prior.sigma = c(10, 0.05))

  res.fixed = inla(y ~ f(idx, model = spde) - 1,
                   data = list(y = y, idx = idx, spde = spde.fixed),
                   control.predictor = list(A = A))


</pre>

<hr /><div style="text-align: center;">[Package <em>INLA</em> version 22.02.16-2 <a href="00Index.html">Index</a>]</div>
</div></body></html>
